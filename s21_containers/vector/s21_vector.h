/**
 * @brief Класс Vector (вектор) представляет собой динамический контейнер,
 * инкапсулирующий в себе динамический массив для более удобной и
 * интуитивной работы с последовательными данными.
 *
 * Данный контейнер предоставляет возможность добавлять произвольное количество
 * элементов с помощью методов push_back() и insert(). В отличие от списка,
 * вектор позволяет обращаться к элементам по индексу. Элементы в векторе
 * хранятся последовательно, что обеспечивает возможность итерирования как с
 * использованием предоставленных итераторов, так и вручную, смещая указатель
 * на элемент вектора. Первый элемент вектора может быть передан в качестве
 * аргумента в функции, ожидающие обычный массив.
 *
 * Динамическое изменение размера вектора происходит не при каждой операции
 * добавления или удаления элемента, а только в случае превышения размера
 * заданного буфера. Вектор хранит два значения, отвечающих за размер:
 * - Размер хранимого массива (метод size()).
 * - Размер буфера (метод capacity()).
 *
 * @tparam T Тип элементов, которые хранит вектор.
 */

#ifndef CPP2_S21_CONTAINERS_SRC_S21_CONTAINERS_VECTOR_S21_VECTOR_H_
#define CPP2_S21_CONTAINERS_SRC_S21_CONTAINERS_VECTOR_S21_VECTOR_H_

#include <algorithm>
#include <cstddef>
#include <iostream>
#include <limits>
#include <stdexcept>

namespace s21 {
template <typename T>
class vector {
 public:
  /*внутриклассовые переопределения типов*/

  using value_type = T;
  using reference = T &;
  using const_reference = const T &;
  using size_type = size_t;
  using iterator = T *;
  using const_iterator = const T *;

  /*публичные методы для взаимодействия с классом*/

  /**
   * @brief Конструктор без аргументов для класса vector.
   *
   * Этот конструктор создает пустой вектор с нулевым размером и емкостью.
   * Объект, созданный с использованием этого конструктора, готов к добавлению
   * элементов.
   */
  vector() : size_(0), capacity_(0), data_(nullptr) {}

  /**
   * @brief Конструктор класса vector с заданным размером.
   *
   * Этот конструктор создает вектор заданного размера, где каждый элемент
   * инициализируется значением по умолчанию.
   *
   * @param n Размер вектора, который нужно создать.
   */
  explicit vector(size_type n)
      : size_(n), capacity_(n), data_(new value_type[n]{}) {}

  /**
   * @brief Конструктор класса vector с использованием списка инициализации.
   *
   * Этот конструктор создает вектор и инициализирует его элементы значениями из
   * списка инициализации.
   *
   * @param items Список инициализации, содержащий элементы для инициализации
   * вектора.
   */
  explicit vector(std::initializer_list<value_type> const &items)
      : size_(items.size()),
        capacity_(items.size()),
        data_(new value_type[items.size()]) {
    size_type i = 0;
    for (const_reference item : items) {
      data_[i++] = item;
    }
  }

  /**
   * @brief Конструктор копирования класса vector.
   *
   * Этот конструктор создает копию существующего вектора `v`.
   *
   * @param v Вектор, который нужно скопировать.
   */
  vector(const vector &v)
      : size_(v.size_),
        capacity_(v.capacity_),
        data_(new value_type[v.capacity_]) {
    for (size_type i = 0; i < size_; ++i) {
      data_[i] = v[i];
    }
  }

  /**
   * @brief Конструктор перемещения класса vector.
   *
   * Этот конструктор перемещает ресурсы из существующего вектора `v` в новый
   * вектор, в результате чего вектор `v` становится пустым.
   *
   * @param v Вектор, из которого ресурсы будут перемещены.
   */
  vector(vector &&v) : size_(v.size_), capacity_(v.capacity_), data_(v.data_) {
    v.data_ = nullptr;
    v.size_ = 0;
    v.capacity_ = 0;
  }

  /**
   * @brief Деструктор класса vector.
   *
   * Деструктор освобождает ресурсы, занимаемые данными вектора, и
   * устанавливает указатели и размеры вектора в нулевые значения.
   */
  ~vector() {
    if (data_ != nullptr) {
      for (size_type i = 0; i < size_; ++i) {
        data_[i].~value_type();  // Вызываем деструкторы для элементов.
      }
      delete[] data_;  // Освобождаем выделенную память.
    }
    data_ = nullptr;
    size_ = 0;
    capacity_ = 0;
  }

  /**
   * @brief Оператор перемещения для класса vector.
   *
   * Этот оператор перемещает данные из вектора `v` в текущий вектор и
   * освобождает ресурсы, занимаемые данными текущего вектора.
   *
   * @param v Вектор, из которого будут перемещены данные.
   * @return Ссылка на текущий вектор после перемещения.
   */
  vector &operator=(vector &&v) {
    if (this == &v) {
      return *this;
    }
    // Очищаем текущий массив
    delete[] data_;

    // Копируем данные из донора
    data_ = v.data_;
    size_ = v.size_;
    capacity_ = v.capacity_;

    // Очищаем данные донора
    v.data_ = nullptr;
    v.size_ = 0;
    v.capacity_ = 0;
    return *this;
  }

  /**
   * @brief Метод для доступа к элементам вектора с проверкой границ.
   *
   * Этот метод позволяет получить доступ к элементу вектора по заданному
   * индексу, выполняя проверку на выход за границы массива.
   *
   * @param pos Индекс элемента, к которому нужно получить доступ.
   * @return Ссылка на элемент вектора.
   * @throw std::out_of_range, если индекс выходит за границы вектора.
   */
  reference at(size_type pos) {
    if (pos >= size_) {
      throw std::out_of_range(
          "vector::_M_range_check: __n (which is " + std::to_string(pos) +
          ") >= this->size() (which is " + std::to_string(this->size_) + ")");
    }
    return data_[pos];
  }

  /**
   * @brief Метод для доступа к указанному элементу без проверки границ.
   *
   * Этот метод позволяет получить доступ к элементу вектора по заданному
   * индексу, без проверки выхода за границы массива.
   *
   * @param pos Индекс элемента, к которому нужно получить доступ.
   * @return Ссылка на элемент вектора.
   */
  reference operator[](size_type pos) const { return data_[pos]; }

  /**
   * @brief Метод для доступа к первому элементу вектора.
   *
   * Этот метод позволяет получить доступ к первому элементу вектора.
   *
   * @return Константная ссылка на первый элемент вектора.
   */
  const_reference front() const { return data_[0]; }

  /**
   * @brief Метод для доступа к последнему элементу вектора.
   *
   * Этот метод позволяет получить доступ к последнему элементу вектора.
   *
   * @return Константная ссылка на последний элемент вектора.
   */
  const_reference back() const { return data_[size_ - 1]; }

  /**
   * @brief Метод для прямого доступа к внутреннему массиву данных.
   *
   * Этот метод возвращает указатель на внутренний массив данных вектора,
   * что позволяет непосредственно работать с данными вектора.
   *
   * @return Указатель на внутренний массив данных вектора.
   */
  value_type *data() { return data_; }

  /*публичные методы для итерирования*/

  /**
   * @brief Метод для получения итератора, указывающего на начало вектора.
   *
   * Этот метод возвращает итератор, указывающий на начало вектора, что
   * позволяет итерироваться по элементам вектора с его начала.
   *
   * @return Итератор, указывающий на начало вектора.
   */
  iterator begin() {
    return data_;  // Где data_ - указатель на первый элемент вектора
  }

  /**
   * @brief Возвращает константный итератор, указывающий на начало вектора.
   *
   * Этот метод возвращает константный итератор, который указывает на первый
   * элемент вектора. Константные итераторы предназначены для чтения элементов и
   * не позволяют изменять содержимое вектора.
   *
   * @return Константный итератор на начало вектора.
   */
  const_iterator cbegin() {
    return data_;  // Где data_ - указатель на первый элемент вектора
  }

  /**
   * @brief Метод для получения итератора, указывающего на конец вектора.
   *
   * Этот метод возвращает итератор, указывающий на позицию за последним
   * элементом вектора, что позволяет итерироваться по элементам вектора до его
   * конца.
   *
   * @return Итератор, указывающий на конец вектора.
   */
  iterator end() {
    return data_ + size_;  // Где data_ - указатель на начало вектора, size_ -
                           // текущий размер вектора
  }
  /**
   * @brief Возвращает константный итератор, указывающий на конец вектора.
   *
   * Этот метод возвращает константный итератор, который указывает на позицию
   * после последнего элемента вектора. Константные итераторы предназначены для
   * чтения элементов и не позволяют изменять содержимое вектора.
   *
   * @return Константный итератор на конец вектора.
   */
  const_iterator cend() {
    return data_;  // Где data_ - указатель на первый элемент вектора
  }

  /**
   * @brief Метод для проверки, пуст ли контейнер.
   *
   * Этот метод возвращает `true`, если контейнер пуст (не содержит элементов),
   * и `false`, если он содержит хотя бы один элемент.
   *
   * @return `true`, если контейнер пуст; `false`, если он содержит элементы.
   */
  bool empty() {
    bool result = true;
    if (size_) {
      result = false;
    }
    return result;
  }

  /**
   * @brief Метод для получения текущего количества элементов в контейнере.
   *
   * Этот метод возвращает текущее количество элементов, находящихся в
   * контейнере.
   *
   * @return Количество элементов в контейнере.
   */
  size_type size() { return size_; }

  /**
   * @brief Метод для получения максимально возможного количества элементов в
   * контейнере.
   *
   * Этот метод возвращает максимальное количество элементов, которое может
   * содержаться в контейнере. Это значение определяется на основе ограничений
   * аппаратного и программного окружения, таких как максимальный размер объекта
   * данных и доступная память.
   *
   * @return Максимальное количество элементов, которое может содержаться в
   * контейнере.
   */
  size_type max_size() noexcept {
    // Определяем максимальное значение для size_t
    size_type max_size = std::numeric_limits<size_type>::max();

    // Размер элемента данных в векторе (здесь используется int как пример)
    size_type element_size = sizeof(value_type);

    // Вычисляем максимальное количество элементов в векторе
    size_type max_elements = max_size / element_size;
    return max_elements;
  }

  /**
   * @brief Метод для выделения дополнительной памяти для элементов вектора.
   *
   * Этот метод выделяет дополнительную память для элементов вектора, если
   * текущая емкость вектора недостаточна для хранения заданного количества
   * элементов. Если новый размер (`new_size`) меньше или равен текущей емкости
   * вектора, метод ничего не делает.
   *
   * @param new_size Новый размер (емкость) вектора.
   */
  void reserve(size_type new_size) {
    if (new_size < capacity_) return;

    // Необычный способ выделения памяти позволяет избежать вызова деструктора
    // при уничтожении временного массива.
    value_type *tmp =
        reinterpret_cast<T *>(new int8_t[new_size * sizeof(value_type)]);

    // Правильный способ: скопировать с вызовом конструктора, затем, в случае
    // исключения, вызвать деструкторы и освободить память.
    // try {
    //     std::uninitialized_copy(data_, data_ + size_, tmp);
    // } catch (...) {
    //     // Вызов деструкторов только у скопированных элементов
    //     for (size_type i = 0; i < size_; ++i) {
    //         (tmp + i)->~value_type();
    //     }
    //     delete[] reinterpret_cast<int8_t*>(tmp);
    //     throw;
    // }

    // Копируем массив без вызова конструктора, чтобы избежать вызова
    // конструктора по умолчанию, так как не все типы имеют конструктор по
    // умолчанию.
    std::uninitialized_copy(data_, data_ + size_, tmp);

    // Вызываем деструкторы только у старых элементов массива.
    for (size_type i = 0; i < size_; ++i) {
      (data_ + i)->~value_type();
    }

    // Удаляем старый массив, используя интерпретацию к типу int8_t, чтобы
    // избежать вызова деструктора.
    delete[] reinterpret_cast<int8_t *>(data_);
    data_ = tmp;
    capacity_ = new_size;
  }

  /**
   * @brief Метод для получения текущей емкости контейнера.
   *
   * Этот метод возвращает текущую емкость контейнера, то есть количество
   * элементов, которые могут быть хранимы в текущей выделенной памяти.
   *
   * @return Текущая емкость контейнера.
   */
  size_type capacity() { return capacity_; }

  /**
   * @brief Метод для уменьшения использования памяти путем освобождения
   * неиспользуемой памяти.
   *
   * Этот метод уменьшает использование памяти контейнера, освобождая
   * неиспользуемую память, если размер контейнера (`size_`) меньше его текущей
   * емкости (`capacity_`). Метод не меняет количество элементов в контейнере,
   * но может уменьшить емкость для экономии памяти.
   */
  void shrink_to_fit() {
    if (size_ < capacity_) {
      // Необычный способ выделения памяти позволяет избежать вызова деструктора
      // при уничтожении временного массива.
      value_type *tmp =
          reinterpret_cast<T *>(new int8_t[size_ * sizeof(value_type)]);

      // Правильный способ: скопировать с вызовом конструктора, затем, в случае
      // исключения, вызвать деструкторы и освободить память.
      // try {
      //     std::uninitialized_copy(data_, data_ + size_, tmp);
      // } catch (...) {
      //     // Вызов деструкторов только у скопированных элементов
      //     for (size_type i = 0; i < size_; ++i) {
      //         (tmp + i)->~value_type();
      //     }
      //     delete[] reinterpret_cast<int8_t*>(tmp);
      //     throw;
      // }

      // Копируем массив без вызова конструктора, чтобы избежать вызова
      // конструктора по умолчанию, так как не все типы имеют конструктор по
      // умолчанию.
      std::uninitialized_copy(data_, data_ + size_, tmp);
      for (size_type i = 0; i < size_; ++i) {
        (data_ + i)->~value_type();
      }
      delete[] reinterpret_cast<int8_t *>(data_);
      data_ = tmp;
      tmp = nullptr;
      capacity_ = size_;
    }
  }

  /*публичные методы для изменения контейнера*/

  /**
   * @brief Метод для очистки содержимого контейнера.
   *
   * Этот метод удаляет все элементы из контейнера, вызывая деструкторы
   * для каждого элемента. После вызова этого метода контейнер становится
   * пустым.
   */
  void clear() {
    // Вызываем деструкторы только у существующих элементов массива.
    for (size_type i = 0; i < size_; ++i) {
      (data_ + i)->~value_type();
    }
    size_ = 0;
  }

  /**
   * @brief Метод для вставки элементов в указанную позицию и возврата итератора
   * на новый элемент.
   *
   * Этот метод вставляет новый элемент со значением `value` в указанную
   * позицию, обозначенную итератором `pos`, и возвращает итератор, указывающий
   * на новый элемент. Если контейнер достиг своей емкости, перед вставкой может
   * быть выполнено увеличение емкости контейнера.
   *
   * @param pos Итератор, указывающий на позицию, в которую нужно вставить
   * элемент.
   * @param value Значение элемента для вставки.
   * @return Итератор, указывающий на новый элемент.
   */
  iterator insert(iterator pos, const_reference value) {
    if (size_ == capacity_) {
      // Так как при вызове функции reserve происходит изменение адресов
      // элементов массива, нужно запомнить расстояние от начала массива до
      // нужной позиции.
      std::ptrdiff_t diff = pos - begin();
      reserve(size_ == 0 ? 1 : size_ * 2);
      pos = begin() + diff;
    }
    pos->~value_type();
    // Смещаем все позиции после нужного элемента вправо.
    for (iterator it = end(); it > pos; --it) {
      *it = *(it - 1);
    }
    // Стираем данные из текущей позиции.
    new (pos) value_type(value);  // Вставляем данные в нужную позицию.
    ++size_;
    return pos;
  }

  /**
   * @brief Метод для удаления элемента по указанной позиции.
   *
   * Этот метод удаляет элемент в позиции, обозначенной итератором `pos`. Все
   * элементы, следующие за удаляемым элементом, сдвигаются влево для замены
   * удаленного элемента. Размер контейнера уменьшается на 1.
   *
   * @param pos Итератор, указывающий на позицию элемента для удаления.
   */
  void erase(iterator pos) {
    pos->~value_type();
    while (pos != end()) {
      *pos = *(pos + 1);  // Смещаем все элементы правее удаляемого влево.
      pos++;
    }
    --size_;
  }

  /**
   * @brief Метод для добавления элемента в конец контейнера.
   *
   * Этот метод добавляет новый элемент со значением `value` в конец контейнера.
   * Если контейнер достиг своей емкости, перед добавлением может быть выполнено
   * увеличение емкости контейнера.
   *
   * @param value Значение элемента для добавления в конец контейнера.
   */
  void push_back(const_reference value) {
    if (size_ == capacity_) {
      reserve(size_ == 0 ? 1 : size_ * 2);
    }
    new (data_ + size_) value_type(value);
    ++size_;
  }

  /**
   * @brief Метод для удаления последнего элемента из контейнера.
   *
   * Этот метод удаляет последний элемент из контейнера, вызывая его деструктор.
   * Размер контейнера уменьшается на 1.
   */
  void pop_back() {
    --size_;
    data_[size_].~value_type();  // Вызываем деструктор последнего элемента.
  }

  /**
   * @brief Метод для обмена содержимым между двумя контейнерами.
   *
   * Этот метод обменивает содержимое текущего контейнера с содержимым другого
   * контейнера `other`. После обмена, текущий контейнер будет содержать
   * элементы из `other`, а `other` будет содержать элементы из текущего
   * контейнера. Емкость и размер обоих контейнеров также могут измениться.
   *
   * @param other Другой контейнер для обмена содержимым.
   */
  void swap(vector &other) {
    std::swap(data_, other.data_);
    std::swap(size_, other.size_);
    std::swap(capacity_, other.capacity_);
  }

  /**
   * @brief Вставляет элементы из списка аргументов в вектор в указанную
   * позицию.
   *
   * Эта функция позволяет вставить несколько элементов в вектор в заданную
   * позицию, используя список аргументов. Вставка начнется с позиции, указанной
   * аргументом `pos`.
   *
   * @param pos Константный итератор, указывающий на позицию в векторе, перед
   *            которой будут вставлены элементы.
   * @param args Аргументы, представляющие элементы, которые будут вставлены в
   *             вектор.
   * @return Итератор, указывающий на последний вставленный элемент. Это может
   *         быть полезно, если вам нужно знать, где закончилась вставка.
   *
   * Пример использования:
   * \code{.cpp}
   * s21::vector<int> v{1, 2, 3};
   * auto pos = v.cbegin() + 1;
   * v.insert_many(pos, 6, 7, 8);
   * // Теперь вектор v содержит: {1, 6, 7, 8, 2, 3}
   * \endcode
   */
  template <typename... Args>
  iterator insert_many(const_iterator pos, Args &&...args) {
    vector<value_type> tmp{args...};
    iterator cur_pos = begin() + (pos - cbegin());
    for (size_t i = 0; i < tmp.size(); ++i) {
      cur_pos =
          insert(cur_pos, tmp[i]) + 1;  //двигаем итератор на след. позицию
    }

    return cur_pos;
  }

  /**
   * @brief Вставляет несколько элементов в конец контейнера.
   *
   * Этот метод позволяет вставить несколько элементов в конец контейнера.
   * Элементы передаются в виде аргументов типа `Args`. Каждый элемент будет
   * вставлен в конец контейнера.
   *
   * @param args Переменное число аргументов, представляющих элементы для
   * вставки.
   */
  template <typename... Args>
  void insert_many_back(Args &&...args) {
    vector<value_type> tmp{args...};
    for (size_t i = 0; i < tmp.size(); ++i) {
      insert(end(), tmp[i]);
    }
  }

 private:
  size_type size_;
  size_type capacity_;
  value_type *data_ = nullptr;
};
}  // namespace s21
#endif  // CPP2_S21_CONTAINERS_SRC_S21_CONTAINERS_VECTOR_S21_VECTOR_H_